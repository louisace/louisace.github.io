{"meta":{"title":"Louis","subtitle":"Louis Blog","description":null,"author":"Louis","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"数据挖掘关联分析-Apriori算法","slug":"数据分析apriori算法关联分析","date":"2018-01-10T09:32:11.534Z","updated":"2017-05-25T12:49:42.429Z","comments":true,"path":"2018/01/10/数据分析apriori算法关联分析/","link":"","permalink":"http://yoursite.com/2018/01/10/数据分析apriori算法关联分析/","excerpt":"","text":"1、关联分析关联分析是在大规模数据集中寻找感兴趣关系的任务。这些关系可以分为两种形式： 频繁项集 关联规则 频繁项集是经常出现在一块儿的物品的集合，关联规则人暗示两物品之间存在很强的关系。 下面举一个例子，说明这个概念： | 交易号码 | 商品 | | —- | :———-: | | 0 | 豆奶、莴苣 | | 1 | 莴苣、尿布、葡萄酒、甜菜 | | 2 | 豆奶、尿布、葡萄酒、橙汁 | | 3 | 莴苣、豆奶、尿布、葡萄酒 | | 4 | 莴苣、豆奶、尿布、橙汁 | ​ 某杂货店交易清单 频繁项集是指那些经常出现在一起的商品集合，图中的集合{葡萄酒,尿布,豆奶}就是频繁项集的一个例子。从这个数据集中也可以找到诸如尿布-&gt;葡萄酒的关联规则，即如果有人买了尿布，那么他很可能也会买葡萄酒。 我们用支持度和可信度来度量这些有趣的关系。一个项集的支持度（support）被定义数据集中包含该项集的记录所占的比例。如上图中，{豆奶}的支持度为4/5，{豆奶,尿布}的支持度为3/5。支持度是针对项集来说的，因此可以定义一个最小支持度，而只保留满足最小值尺度的项集。 可信度或置信度（confidence）是针对关联规则来定义的。规则{尿布}➞{啤酒}的可信度被定义为”支持度({尿布,啤酒})/支持度({尿布})”，由于{尿布,啤酒}的支持度为3/5，尿布的支持度为4/5，所以”尿布➞啤酒”的可信度为3/4。这意味着对于包含”尿布”的所有记录，我们的规则对其中75%的记录都适用。 $$ confidence(x \\rightarrow y) = \\frac {P(Y|X)=P(X \\bigcup Y)}{P(X)}= \\frac {support_count(X \\bigcup Y)}{support_count(X)} $$ Apriori原理 假设我们有一家经营着4种商品（商品0，商品1，商品2和商品3）的杂货店，2图显示了所有商品之间所有的可能组合： ​ 图2 集合{0,1,2,3,4}中所有可能的项集组合 对于单个项集的支持度，我们可以通过遍历每条记录并检查该记录是否包含该项集来计算。对于包含N中物品的数据集共有 $2^N-1$种项集组合，重复上述计算过程是不现实的。 研究人员发现一种所谓的Apriori原理，可以帮助我们减少计算量。Apriori原理是说如果某个项集是频繁的，那么它的所有子集也是频繁的。更常用的是它的逆否命题，即如果一个项集是非频繁的，那么它的所有超集也是非频繁的。 在图3中，已知阴影项集{2,3}是非频繁的。利用这个知识，我们就知道项集{0,2,3}，{1,2,3}以及{0,1,2,3}也是非频繁的。也就是说，一旦计算出了{2,3}的支持度，知道它是非频繁的后，就可以紧接着排除{0,2,3}、{1,2,3}和{0,1,2,3}。 ​ 图3 图中给出了所有可能的项集，其中非频繁项集用灰色表示。 Apriori算法R语言实现12345678910111213141516171819Apriori &lt;- function(data, I, MIN_SUP, parameter = NULL)&#123; f &lt;- CreateItemsets() c &lt;- FindFrequentItemsets(data, I, 1, MIN_SUP) k &lt;- 2 len4data &lt;- GetDatasetSize(data) while( !IsEmpty(c[[k-1]])) &#123; f[[k]] &lt;- AprioriGen(c[k-1]) for( idx in 1:len4data ) &#123; ft &lt;- GetSubSet(f[k], data[[idx]]) len4ft &lt;- GetDatasetSize(ft) for( jdx in 1:len4ft )&#123; IncreaseSupportCount(f[[k]], ft[jdx]) &#125; &#125; c[[k]] &lt;- FindFrequestItemset(f[k], I, l, MIN_SUP) k &lt;- k+1 &#125; c &#125; Apriori算法Python实现前面提到，关联分析的目标包括两项：发现频繁项集和发现关联规则。首先需要找到频繁项集，然后才能获得关联规则（正如前文所讲，计算关联规则的可信度需要用到频繁项集的支持度）。 Apriori算法是发现频繁项集的一种方法。Apriori算法的两个输入参数分别是最小支持度和数据集。该算法首先会生成所有单个元素的项集列表。接着扫描数据集来查看哪些项集满足最小支持度要求，那些不满足最小支持度的集合会被去掉。然后，对剩下来的集合进行组合以生成包含两个元素的项集。接下来，再重新扫描交易记录，去掉不满足最小支持度的项集。该过程重复进行直到所有项集都被去掉。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#生成候选项集#建立一个apriori.py文件from numpy import *def loadDataSet(): return [[1, 3, 4], [2, 3, 5], [1, 2, 3, 5], [2, 5]]def createC1(dataSet): C1 = [] for transaction in dataset: for item in transaction: if not [item] in C1: C1.append([item]) C1.sort() return map(frozenset, C1) #C1为元素个数为1的项集（非频繁项集，还没有和最小支持°比较）。map(frozenset, C1)的意思是将C1由python列表转换为不变集合（frozenset，python的数据结构）def scanD(D, Ck, minSupport): ssCnt = &#123;&#125; for tid in D: for can in Ck: if can.issubset(tid): ssCnt[can] = ssCnt.get(can, 0) + 1 numItems = float(len(D)) retList = [] supportData = &#123;&#125; for key in ssCnt: support = ssCnt[key] / numItems if support &gt;= minSupport: reList.insert(0, key) supportData[key] = support return reList, supportData#D为全部数集，Ck为大小为k（包含k个）的候选项集，minSupport为设定的最小支持度。返回值中List在Ck中找出的频繁项集（支持度大于minSupport的），supportData记录各频繁项集的支持度。#通过频繁项集列表Lk和项集个数k生成候选项集Ck+1。def aprioriGen(Lk, k): retList = [] lenLk = len(Lk) for i in range(LenLk): for j in range(i+1, lenLk): #前k-2项相同时，将两个集合合并 L1 = list(Lk[i][:k-2]); L2 = list(Lk[i][:k-2]) L1.sort(); L2.sort() if L1 == L2: reList.append(Lk[i] | Lk[j]) return reList#生成的过程中，首选对每个项集按元素排序，然后每次比较两个项集，只有在前k-1项相同时才将这两项合并。这样做是因为函数并非要两两合并各个集合，那样生成的集合并非都是k+1项的。在限制项数为k+1的前提下，只有在前k-1项相同、最后一项不相同的情况下合并才为所需要的新候选项集。#Apriori算法主函数def apriori(dataset, minSupport = 0.5): C1 = createC1(dataSet) D = map(ser, dataset) L1, supportData = scanD(D, C1, minSupport) L = [L1] k = 2 while(len(L[k-2]) &gt; 0): Ck = aprioriGen(L[k-2], k) Lk, supk = scanD(D, Ck, minSupport) supportData.update(supk) L.append(Lk) k += 1 return L, supportData 由于篇幅过长，下一节继续介绍Apriori算法。 感谢《使用Apriori算法和FP-growth算法进行关联分析》的支持","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-10T09:22:26.149Z","updated":"2018-01-10T09:22:26.149Z","comments":true,"path":"2018/01/10/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}